
死锁
<!-- TOC -->

- [原因:](#原因)
- [必要条件:](#必要条件)
- [处理死锁基本方法:](#处理死锁基本方法)
    - [预防死锁(摒弃除1以外的条件)](#预防死锁摒弃除1以外的条件)
    - [避免死锁](#避免死锁)
    - [检测死锁(资源分配图)](#检测死锁资源分配图)
    - [解除死锁](#解除死锁)
    - [鸵鸟策略](#鸵鸟策略)

<!-- /TOC -->
# 原因:

1. 竞争资源
2. 程序推进顺序不当

# 必要条件:

1. 互斥条件
2. 请求和保持条件
3. 不剥夺条件
4. 环路等待条件

# 处理死锁基本方法:

## 预防死锁(摒弃除1以外的条件)
* 破坏互斥
* 破坏不可抢占
* 破坏环路等待
## 避免死锁
* 如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每个进程运行完毕，则成为该序列是安全的。
* 银行家算法
## 检测死锁(资源分配图)
* 每种资源只有一个：通过有向图是否成环来判断
* 多个资源：主要是通过矩阵来判断剩余资源于请求资源的关系
## 解除死锁
* 利用抢占恢复
* 利用回滚恢复
* 通过杀死进程恢复
## 鸵鸟策略
    啥也不管，当做没发生

[死锁概念处理策略详细介绍](https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/10.html)