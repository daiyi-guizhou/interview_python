
[数据库分库分表、读写分离的原理实现，使用场景](https://youzhixueyuan.com/the-principle-of-separating-tables-reading-and-writing-and-using-scenarios.html)
[数据库分片（Database Sharding)详解](https://zhuanlan.zhihu.com/p/57185574) ---待补充



为什么要分库分表和读写分离？
类似淘宝网这样的网站，海量数据的存储和访问成为了系统设计的瓶颈问题，日益增长的业务数据，无疑对数据库造成了相当大的负载，同时对于系统的稳定性和扩展性提出很高的要求。随着时间和业务的发展，数据库中的表会越来越多，表中的数据量也会越来越大，相应地，数据操作的开销也会越来越大；另外，无论怎样升级硬件资源，单台服务器的资源（CPU、磁盘、内存、网络IO、事务数、连接数）总是有限的，最终数据库所能承载的数据量、数据处理能力都将遭遇瓶颈。分表、分库和读写分离可以有效地减小单台数据库的压力。

分库分表的原理和实现
1.什么是分区、分表、分库

分区

就是把一张表的数据分成N个区块，在逻辑上看最终只是一张表，但底层是由N个物理区块组成的，分区实现比较简单，数据库mysql、oracle等很容易就可支持。

分表

就是把一张表按一定的规则分解成N个具有独立存储空间的实体表。系统读写时需要根据定义好的规则得到对应的字表明，然后操作它。

分库

一旦分表，一个库中的表会越来越多

将整个数据库比作图书馆，一张表就是一本书。当要在一本书中查找某项内容时，如果不分章节，查找的效率将会下降。而同理，在数据库中就是分区。

2.什么时候考虑使用分区？

一张表的查询速度已经慢到影响使用的时候。

 sql经过优化
 数据量大
 表中的数据是分段的
 对数据的操作往往只涉及一部分数据，而不是所有的数据
分区解决的问题

主要可以提升查询效率

分区的实现方式（简单），例如：

mysql5 开始支持分区功能

CREATE TABLE sales (

id INT AUTO_INCREMENT,

amount DOUBLE NOT NULL,

order_day DATETIME NOT NULL,

PRIMARY KEY(id, order_day)

) ENGINE=Innodb

PARTITION BY RANGE(YEAR(order_day)) (

PARTITION p_2010 VALUES LESS THAN (2010),

PARTITION p_2011 VALUES LESS THAN (2011),

PARTITION p_2012 VALUES LESS THAN (2012),

PARTITION p_catchall VALUES LESS THAN MAXVALUE);

3.什么时候考虑分表？

 一张表的查询速度已经慢到影响使用的时候。
 sql经过优化
 数据量大
 当频繁插入或者联合查询时，速度变慢
4.分表解决的问题

分表后，单表的并发能力提高了，磁盘I/O性能也提高了，写操作效率提高了

 查询一次的时间短了
 数据分布在不同的文件，磁盘I/O性能提高
 读写锁影响的数据量变小
 插入数据库需要重新建立索引的数据减少
5.分表的实现方式（复杂）

需要业务系统配合迁移升级，工作量较大。

6.常见分表、分库常用策略：

1.平均进行分配hash(object)%N(适用于简单架构)。

2.按照权重进行分配且均匀轮询。

3.按照业务进行分配。

4.按照一致性hash算法进行分配(适用于集群架构，在集群中节点的添加和删除不会造成数据丢失，方便数据迁移)。

7.分库分表中间件

分表又分为单库分表（表名不同）和多库分表（表名相同），不管使用哪种策略都还需要自己去实现路由，制定路由规则等，可以考虑使用开源的分库分表中间件，无侵入应用设计，例如淘宝的tddl等。

阿里P8架构师谈：数据库分库分表、读写分离的原理实现，使用场景
读写分离的原理和实现
1、什么是读写分离

读写分离，基本的原理是让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库处理SELECT查询操作。数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。

2、为什么要读写分离呢？

因为数据库的“写”（写10000条数据到oracle可能要3分钟）操作是比较耗时的。

但是数据库的“读”（从oracle读10000条数据可能只要5秒钟）。

所以读写分离，解决的是，数据库的写入，影响了查询的效率。

3、什么时候要读写分离？

数据库不一定要读写分离，如果程序使用数据库较多时，而更新少，查询多的情况下会考虑使用，利用数据库 主从同步 。可以减少数据库压力，提高性能。当然，数据库也有其它优化方案。memcache 或是 表折分，或是搜索引擎。都是解决方法。

阿里P8架构师谈：数据库分库分表、读写分离的原理实现，使用场景
4.主从复制、读写分离的基本设计

在实际的生产环境中，对数据库的读和写都在同一个数据库服务器中，是不能满足实际需求的。无论是在安全性、高可用性还是高并发等各个方面都是完全不能满足实际需求的。因此，通过主从复制的方式来同步数据，再通过读写分离来提升数据库的并发负载能力。

一台主、多台从，主提供写操作，从提供读操作。

读写分离的实现：

我们只需要实现读写分离，主从复制数据一般由数据库级来实现同步，当然也可以自己去实现同步，只是需要考虑的点比较多。

分库分表、读写分离总结：
1.分区

对业务透明，分区只不过把存放数据的文件分成了许多小块，根据一定的规则把数据文件(MYD)和索引文件（MYI）进行了分割，分区后的表呢，还是一张表。

2.分表

当数据量大到一定程度的时候，都会导致处理性能的不足，这个时候就没有办法了，只能进行分表处理。也就是把数据库当中数据根据按照分库原则分到多个数据表当中，这样，就可以把大表变成多个小表，不同的分表中数据不重复，从而提高处理效率。

3.分库

分表和分区都是基于同一个数据库里的数据分离技巧，对数据库性能有一定提升，但是随着业务数据量的增加，原来所有的数据都是在一个数据库上的，网络IO及文件IO都集中在一个数据库上的，因此CPU、内存、文件IO、网络IO都可能会成为系统瓶颈。

当业务系统的数据容量接近或超过单台服务器的容量、QPS/TPS接近或超过单个数据库实例的处理极限等此时，往往是采用垂直和水平结合的数据拆分方法，把数据服务和数据存储分布到多台数据库服务器上。

4.读写分离方案

当数据库读远大于写，查询多的情况，就可以考虑主数据负责写操作，从数据库负责读操作，一主多重，从而把数据读写分离，最后还可以结合redis等缓存来配合分担数据的读操作，大大的降低后端数据库的压力



分库分表的难点
垂直分库带来的问题和解决思路：

跨库 join 的问题
在拆分之前，系统中很多列表和详情页所需的数据是可以通过 sql join 来完成的。而拆分后，数据库可能是分布式在不同实例和不同的主机上，join 将变得非常麻烦。而且基于架构规范，性能，安全性等方面考虑，一般是禁止跨库 join 的。那该怎么办呢？首先要考虑下垂直分库的设计问题，如果可以调整，那就优先调整。如果无法调整的情况，下面笔者将结合以往的实际经验，总结几种常见的解决思路，并分析其适用场景
三、如何进行跨库连表查询呢？
      就上面的考虑来看，我想要查询到这个学生的信息和所在学校的信息，如果t_student和t_school在一个库中，就可以通过join进行查询：

SELECT * from t_student s1 LEFT JOIN t_school s2 on s2.id = s1.school_id where s1.id='1'
1
      但是，现在两张表不在一个数据库中，如何解决呢？有没有跨库查询SQL Join的语句呢？

【解决方案】
3.1 开启FEDERATED引擎
      在前面的博客中，小编分享过，Mysql的常见的引擎类型有MyIsam，InnoDB等。并且我们可以通过show engines;命令来查看，数据库支持的所有的引擎。

      如果要想实现跨库Join查询，我们可以使用FEDERATED引擎来实现。但是默认情况下，FEDERATED引擎是关闭的，所以就需要我们去my.cnf的配置文件中进行相关的配置。

在my.cnf 文件中添加federated，然后重启启动mysql服务
      my.cnf:

这里写图片描述
重启mysql服务
service mysqld restart
1
3.2 建立链接表
      限制：

      1.本地结构字段可以是远程表的部分字段，字段必须相同

      2.不支持事务

      3.不支持表结构修改

      建表语句格式：

CREATE TABLE xxx(...) ENGINE=FEDERATED CONNECTION='mysql://[name]:[password]@[location]:[port]/[db-name]/[table-name]'
1
      说明：
      name：远程数据库账号
      password：远程数据库密码
      location：远程数据库Ip地址
      port：数据库端口
      db-name：数据库名字
      table-name：表名

      【例子】
      建立链接t_school表：


CREATE TABLE `t_school` (
  `id` varchar(22) NOT NULL,
  `school_name` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=FEDERATED DEFAULT CHARSET=latin1 COMMENT='学校表－链接表' CONNECTION='mysql://root:root@192.168.22.177:3306/db2/t_school';
1
2
3
4
5
6
      经过这些步骤，我们就把另外一个库的表，链接到了我们操作的库上了。这样就可以使用JOIN等语句，间接进行跨库操作啦
      
      
      
全局表

所谓全局表，就是有可能系统中所有模块都可能会依赖到的一些表。比较类似我们理解的“数据字典”。为了避免跨库 join 查询，我们可以将这类表在其他每个数据库中均保存一份。同时，这类数据通常也很少发生修改（甚至几乎不会），所以也不用太担心“一致性”问题。

字段冗余

这是一种典型的反范式设计，在互联网行业中比较常见，通常是为了性能来避免 join 查询。

举个电商业务中很简单的场景：

“订单表”中保存“卖家 Id”的同时，将卖家的“Name”字段也冗余，这样查询订单详情的时候就不需要再去查询“卖家用户表”。

字段冗余能带来便利，是一种“空间换时间”的体现。但其适用场景也比较有限，比较适合依赖字段较少的情况。最复杂的还是数据一致性问题，这点很难保证，可以借助数据库中的触发器或者在业务代码层面去保证。当然，也需要结合实际业务场景来看一致性的要求。就像上面例子，如果卖家修改了 Name 之后，是否需要在订单信息中同步更新呢？

数据同步

定时 A 库中的 tab_a 表和 B 库中 tbl_b 有关联，可以定时将指定的表做同步。当然，同步本来会对数据库带来一定的影响，需要性能影响和数据时效性中取得一个平衡。这样来避免复杂的跨库查询。笔者曾经在项目中是通过 ETL 工具来实施的。

系统层组装

在系统层面，通过调用不同模块的组件或者服务，获取到数据并进行字段拼装。说起来很容易，但实践起来可真没有这么简单，尤其是数据库设计上存在问题但又无法轻易调整的时候。

具体情况通常会比较复杂。下面笔者结合以往实际经验，并通过伪代码方式来描述。

简单的列表查询的情况

分库分表的几种常见形式以及可能遇到的难

伪代码很容易理解，先获取“我的提问列表”数据，然后再根据列表中的 UserId 去循环调用依赖的用户服务获取到用户的 RealName，拼装结果并返回。

有经验的读者一眼就能看出上诉伪代码存在效率问题。循环调用服务，可能会有循环 RPC，循环查询数据库…不推荐使用。再看看改进后的：

分库分表的几种常见形式以及可能遇到的难

这种实现方式，看起来要优雅一点，其实就是把循环调用改成一次调用。当然，用户服务的数据库查询中很可能是 In 查询，效率方面比上一种方式更高。（坊间流传 In 查询会全表扫描，存在性能问题，传闻不可全信。其实查询优化器都是基本成本估算的，经过测试，在 In 语句中条件字段有索引的时候，条件较少的情况是会走索引的。这里不细展开说明，感兴趣的朋友请自行测试）。
[分库分表可能遇到的难题](https://www.infoq.cn/article/key-steps-and-likely-problems-of-split-table)
[分库分表后端join问题](https://blog.csdn.net/kisscatforever/article/details/78974576)

